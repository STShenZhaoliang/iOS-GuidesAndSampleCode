## 1.Providing Haptic Feedback
提供触觉反馈
On iPhone 7 and iPhone 7 Plus, haptics provide additional ways to physically engage users with tactile feedback that gets attention and reinforces actions. Some system-provided interface elements, such as pickers, switches, and sliders, automatically provide haptic feedback as users interact with them.

To give you the ability to generate haptics in an app that targets iOS 10, UIKit introduces the new 
`UIFeedbackGenerator` class and three concrete subclasses, each of which enables haptics that are 
appropriate for a specific scenario, as shown in Table 1.

Table 1  Concrete feedback generator classes and example usages

| Class name | Example usage |
| --- | --- |
|  UIImpactFeedbackGenerator| Provides a physical experience that complements the visual feedback for an action or task. For example, the user might feel a thud when a view slides into place or two objects collide. |
| UINotificationFeedbackGenerator |  Indicates that a task or action, such as depositing a check or unlocking a vehicle, has completed, failed, or produced a warning of some kind.|
| UISelectionFeedbackGenerator | Indicates that the selection is actively changing. For example, the user feels light taps while scrolling a picker wheel. |


Using one of the concrete subclasses, you ask the system to generate haptics for a specific scenario and iOS manages the strength and behavior of the feedback based on the scenario you choose. In addition, you can call the prepare method of UIFeedbackGenerator to inform the system that haptic feedback is about to be required and to minimize latency. To learn how to use haptics to provide the best user experience in your app, see “Haptic Feedback” in iOS Human Interface Guidelines.

## 2.SiriKit

Apps that provide services in specific domains can use SiriKit to make those services available from Siri on iOS. Making your services available requires creating one or more app extensions using the Intents and Intents UI frameworks. SiriKit supports services in the following domains:

Audio or video calling

Messaging

Sending or receiving payments

Searching photos

Booking a ride

Managing workouts

Adjusting settings in a CarPlay-enabled vehicle (automotive vendors only)

Making restaurant reservations (requires additional support from Apple)

When the user makes a request involving your service, SiriKit sends your extension an intent object, which describes the user’s request and provides any data related to that request. You use the intent object to provide an appropriate response object, which includes details of how you can handle the user’s request. Siri typically handles all user interactions, but you can use an extension to provide custom UI that incorporates branding or additional information from your app.

SiriKit also provides a mechanism you can use to tell the system about the interactions and activities that occur within your app. SiriKit defines an interaction object, which combines an intent with information about the intent-handling process, including details such as the start time and duration of a specific occurrence of the process. If your app is registered as capable of handling an activity that has the same name as an intent, the system can launch your app with an interaction object containing that intent even if you don’t provide an Intents app extension.

Ride booking is supported by both Maps and Siri, and users can also make restaurants reservations with Maps. Your Intents extension handles interactions that originate from the Maps app in the same way that it handles requests coming from Siri. If you customize the user interface, your Intents UI extension can also configure itself differently, depending on whether the request came from Siri or Maps.

To learn how to support SiriKit and give users new ways to access your services, read SiriKit Programming Guide. When you’re ready to implement the app extensions that handle various intents, see Intents Framework Reference and Intents UI Framework Reference.

## 3.Proactive Suggestions

iOS 10 introduces new ways to increase engagement with your app by helping the system suggest your app to users at appropriate times. If you adopted app search in your iOS 9 app, you gave users access to activities and content deep within your app through Spotlight and Safari search results, Handoff, and Siri suggestions. In iOS 10 and later, you can provide information about what users do in your app, which helps the system promote your app in additional places, such as the keyboard with QuickType suggestions, Maps and CarPlay, the app switcher, Siri interactions, and (for media playing apps) the lock screen. These opportunities for enhanced integration with the system are supported by a collection of technologies, such as NSUserActivity, web markup defined by Schema.org, and APIs defined in the Core Spotlight, MapKit, UIKit, and Media Player frameworks.

In iOS 10, the NSUserActivity object includes the mapItem property, which lets you provide location information that can be used in other contexts. For example, if your app displays hotel reviews, you can use the mapItem property to hold the location of the hotel the user is viewing so that when the user switches to a travel planning app, that hotel’s location is automatically available. And if you support app search, you can use the new text-based address component properties in CSSearchableItemAttributeSet, such as thoroughfare and postalCode, to fully specify locations to which the user may want to go. Note that when you use the mapItem property, the system automatically populates the contentAttributeSet property, too.

To share a location with the system, be sure to specify latitude and longitude values, in addition to values for the address component properties in CSSearchableItemAttributeSet. It’s also recommended that you supply a value for the namedLocation property, so that users can view the name of the location, and the phoneNumbers property, so that users can use Siri to initiate a call to the location.

In iOS 9, adding markup to the structured data on your website enriched the content that users see in Spotlight and Safari search results. In iOS 10, you can use location-related vocabulary defined at Schema.org, such as PostalAddress, to further enhance the user’s experience. For example, if users view a location described on your website, the system can suggest the same location when users switch to Maps. Note that Safari supports both JSON-LD and Microdata encodings of Schema.org vocabularies.

UIKit introduces the textContentType property in the UITextInputTraits protocol so that you can specify the semantic meaning of the content you expect users to enter in a text area. When you provide this information, the system can in some cases automatically select an appropriate keyboard and improve keyboard corrections and proactive integration with information supplied from other apps and websites. For example, if you use UITextContentTypeFullStreetAddress to tell the system that you expect users to enter a complete address in a text field, the system can suggest the address of a location the user was recently viewing.

If your app plays media and you use the MPPlayableContentManager APIs, iOS 10 helps you let users view album art and play media through your app on the lock screen.

If your ride-sharing app uses the MKDirectionsRequest API, iOS 10 can display it in the app switcher when the user is likely to want a ride. To register as a ride-share provider, specify the MKDirectionsModeRideShare value for the MKDirectionsApplicationSupportedModes key in your Info.plist file. If your app supports only ride sharing, the system suggests your app with text that begins “Get a ride to...”; if your app supports both ride sharing and another routing type (such as Automobile or Bike), the system uses the text “Get directions to...”. Note that the MKMapItem object you receive may not include latitude and longitude information and would require geocoding.

## 4.Integrating with the Messages App

In iOS 10, you can create app extensions that interact with the Messages app and let users send text, stickers, media files, and interactive messages, including interactive messages that update as each recipient responds to the message. You can also make your publicly accessible images available to the #images app in Messages.

You can create two types of app extensions:

A Sticker pack provides a set of stickers that users can add to their Messages content.

An iMessage app lets you present a custom user interface within the Messages app, create a sticker browser, include text, stickers, and media files within a conversation, and create, send, and update interactive messages.

An iMessage app can also help users search images that you host on your app’s related website while they’re in the Messages app.

You can create a Sticker pack without writing any code: Simply drag images into the Sticker Pack folder inside the Stickers asset catalog in Xcode.

To develop an iMessage app, you use the APIs in the Messages framework (Messages.framework). To learn about the Messages framework, see Messages Framework Reference. For general information about creating app extensions, see App Extension Programming Guide.

The #images app in Messages shows people popular images from public websites. Your publicly accessible images can be included in #images search results after Apple's web crawler, known as Applebot, has scanned your website. To make your public images available in #images, follow these steps:

Implement an iMessage app.

Add the com.apple.developer.associated-domains key to your app’s entitlements. Include a list of the web domains that host the images you want to make searchable. For each domain, specify the spotlight-image-search service in an entry such as spotlight-image-search:yourdomain.com.

Add an apple-app-site-association file to your website. Add a dictionary for the spotlight-image-search service and include your app ID, which is the team ID or app ID prefix, followed by the bundle ID. You can specify up to 500 paths and patterns that should be included for indexing for #images (for some examples of website paths, see the universal links examples in Creating and Uploading the Association File).

Allow crawling by Applebot (to learn more, see About Applebot).

## 5.User Notifications

iOS 10 introduces the User Notifications framework (UserNotifications.framework), which supports the delivery and handling of local and remote notifications. You use the classes of this framework to schedule the delivery of local notifications based on specific conditions, such as time or location. Apps and app extensions can use this framework to receive and potentially modify local and remote notifications when they are delivered to the user’s device.

Also introduced in iOS 10, the User Notifications UI framework (UserNotificationsUI.framework) lets you customize the appearance of local and remote notifications when they appear on the user’s device. You use this framework to define an app extension that receives the notification data and provides the corresponding visual representation. Your extension can also respond to custom actions associated with those notifications.

## 6.Speech Recognition

iOS 10 introduces a new API that supports continuous speech recognition and helps you build apps that can recognize speech and transcribe it into text. Using the APIs in the Speech framework (Speech.framework), you can perform speech transcription of both real-time and recorded audio. For example, you can get a speech recognizer and start simple speech recognition using code like this:

let recognizer = SFSpeechRecognizer()

let request = SFSpeechURLRecognitionRequest(url: audioFileURL)

recognizer?.recognitionTask(with: request, resultHandler: { (result, error) in

print (result?.bestTranscription.formattedString)

})

As with accessing other types of protected data, such as Calendar and Photos data, performing speech recognition requires the user’s permission (for more information about accessing protected data classes, see Security and Privacy Enhancements). In the case of speech recognition, permission is required because data is transmitted and temporarily stored on Apple’s servers to increase the accuracy of recognition. To request the user’s permission, you must add the NSSpeechRecognitionUsageDescription key to your app’s Info.plist file and provide content that describes your app’s usage.

When you adopt speech recognition in your app, be sure to indicate to users when their speech is being recognized so that they can avoid making sensitive utterances at that time.

## 7.Wide Color

Most graphics frameworks throughout the system, including Core Graphics, Core Image, Metal, and AVFoundation, have substantially improved support for extended-range pixel formats and wide-gamut color spaces. By extending this behavior throughout the entire graphics stack, it is easier than ever to support devices with a wide color display. In addition, UIKit standardizes on working in a new extended sRGB color space, making it easy to mix sRGB colors with colors in other, wider color gamuts without a significant performance penalty.

Here are some best practices to adopt as you start working with Wide Color.

In iOS 10, the UIColor class uses the extended sRGB color space and its initializers no longer clamp raw component values to between 0.0 and 1.0. If your app relies on UIKit to clamp component values (whether you’re creating a color or asking a color for its component values), you need to change your app’s behavior when you link against iOS 10.

When performing custom drawing in a UIView on an iPad Pro (9.7 inch), the underlying drawing environment is configured with an extended sRGB color space.

If your app renders custom image objects, use the new UIGraphicsImageRenderer class to control whether the destination bitmap is created using an extended-range or standard-range format.

If you are performing your own image processing on wide-gamut devices using a lower level API, such as Core Graphics or Metal, you should use an extended range color space and a pixel format that supports 16-bit floating-point component values. When clamping of color values is necessary, you should do so explicitly.

Core Graphics, Core Image, and Metal Performance Shaders provide new options for easily converting colors and images between color spaces.

## 8.Adapting to the True Tone Display

The True Tone display uses ambient light sensors to automatically adjust the color and intensity of the display to match the lighting conditions of the current environment. To ensure that your app works well with the standard color shift provided by True Tone, add the new UIWhitePointAdaptivityStyle key to your Info.plist file to describe your app’s primary visual content. For example:

If your app is a photo editing app, color fidelity is more important than automatic adjustment to the environmental white point. In this case, you can use the UIWhitePointAdaptivityStylePhoto style to reduce the strength of True Tone shift applied by the system.

If your app is a reading app, conformance with the environmental white point is helpful to users. In this case, you can use the UIWhitePointAdaptivityStyleReading style to increase the strength of True Tone shift applied by the system.

## 9.App Search Enhancements

iOS 10 and the Core Spotlight framework introduce several enhancements to app search:

In-app searching

Search continuation

Crowdsourcing deep link popularity with differential privacy

Visualization of validation results

The new CSSearchQuery class supports in-app searches of content that you index using existing Core Spotlight APIs. Using this API can eliminate the need to maintain your own separate search index and lets you take advantage of Spotlight’s powerful search technology and matching rules to allow users to search for content without leaving your app, just as they do within Mail, Messages, and Notes.

In iOS 9, using search APIs (such as Core Spotlight, NSUserActivity, and web markup) to index content within your app let users search for that content using the Spotlight and Safari search interfaces. In iOS 10, you can use new Core Spotlight symbols to let users continue a search they began in Spotlight when they open your app. To enable this feature, add the CoreSpotlightContinuation key to your Info.plist file, give it the value YES, and update your code to handle an activity continuation of type CSQueryContinuationActionType. The user info dictionary in the NSUserActivity object that you receive in your application:continueUserActivity:restorationHandler: method includes the CSSearchQueryString key, whose value is a string that represents the user’s query.

iOS 10 introduces a differentially private way to help improve the ranking of your app’s content in search results. iOS submits a subset of differentially private hashes to Apple servers as users use your app and as NSUserActivity objects that include a deep link URL and have their eligibleForPublicIndexing property set to YES are submitted to iOS. The differential privacy of the hashes allows Apple to count the frequency with which popular deep links are visited without ever associating a user with a link.

When you test your website markup and deep links using the App Search API Validation tool, it now displays a visual representation of your results, including supported markup, such as that defined at Schema.org. The validation tool can help you see information that the Applebot web crawler has indexed, such as the title, description, URL, and other supported elements. You can access the validation tool here: https://search.developer.apple.com/appsearch-validation-tool. To learn more about supporting deep links and adding markup, see Mark Up Web Content.

To learn how to make your website’s images searchable within the Messages app, see Integrating with the Messages App.

## 10.Widget Enhancements

iOS 10 introduces a new design for the lock screen, which now displays widgets. To ensure that your widget looks good on any background, you can specify widgetPrimaryVibrancyEffect or widgetSecondaryVibrancyEffect, as appropriate (use these properties instead of the deprecated notificationCenterVibrancyEffect property). In addition, widgets now include the concept of display mode (represented by NCWidgetDisplayMode), which lets you describe how much content is available and allows users to choose a compact or expanded view.

## 11.Apple Pay Enhancements

In iOS 10, users can make easy and secure payments using Apple Pay from websites and through interaction with Siri and Maps. For developers, iOS 10 introduces new APIs you can use in code that runs in both iOS and watchOS, the ability to support dynamic payment networks, and a new sandbox testing environment.

iOS 10 introduces new APIs that help you incorporate Apple Pay directly into your website. When you support Apple Pay in your website, users browsing with Safari in iOS or macOS can make payments using their cards in Apple Pay on their iPhone or Apple Watch. To learn more, see ApplePay JS Framework Reference.

The PassKit framework (PassKit.framework) introduces APIs that let you support Apple Pay in places where UIKit is not available. Specifically, PKPaymentAuthorizationController and PKPaymentAuthorizationControllerDelegate enable features provided by PKPaymentAuthorizationViewController and its delegate, but don’t require UIKit. Although the new API is required for supporting Apple Pay in watchOS and in certain intents, it’s recommended that you adopt it in all of your code so that you can provide broad Apple Pay support with a single code base. (To learn more about intents and Siri integration, see SiriKit.)

The PassKit framework also adds features that let card issuers present their cards from within their apps. Specifically, the PKPaymentButtonTypeInStore button type lets you display an Apple Pay button for a card and the presentPaymentPass: method lets you programmatically display the card (the presentPaymentPass: method is defined in PKPassLibrary).

When a new payment network becomes available, your app can automatically support the new network without requiring you to modify and recompile your app. The availableNetworks method lets you discover the networks that are available on the user's device at runtime. In addition, the supportedNetworks property is expanded, so that it can take some payment provider names as an argument. Your app then automatically supports any networks that the payment provider supports. To learn more, see https://developer.apple.com/apple-pay/.

iOS 10 introduces a new testing environment that lets you provision test cards directly on the device. The test environment returns encrypted test payment data. To use this environment, follow these steps:

Create a testing iCloud Account at iTunes Connect.

Log into that account on your device.

Set the desired region for testing.

Use test cards listed at https://developer.apple.com/apple-pay/.

Note: When you switch iCloud accounts, the environment switches automatically.

You must still test your payments using actual cards in an production environment.

## 12.Security and Privacy Enhancements

iOS 10 introduces several changes and additions that help you improve the security of your code and maintain the privacy of user data. To learn more about these items, see https://developer.apple.com/security/.

The new NSAllowsArbitraryLoadsInWebContent key for your Info.plist file gives you a convenient way to allow arbitrary web page loads to work while retaining ATS protections for the rest of your app. To learn more about this key, see NSAppTransportSecurity.

The SecKey API includes improvements for asymmetric key generation. Use the SecKey API instead of the deprecated Common Data Security Architecture (CDSA) APIs.

The RC4 symmetric cipher suite is now disabled by default for all SSL/TLS connections, and SSLv3 is no longer supported in the Secure Transports API. It’s recommended that you stop using the SHA-1 and 3DES cryptographic algorithms as soon as possible.

The UIPasteboard class supports the Clipboard feature, which lets users copy and paste between devices, and includes API you can use to restrict a pasteboard to a specific device and set an expiration timestamp after which the pasteboard is cleared. Additionally, named pasteboards are no longer persistent—instead, you should use shared containers—and the “Find” pasteboard (that is, the pasteboard identified by the UIPasteboardNameFind constant) is unavailable.

You must statically declare your app’s intended use of protected data classes by including the appropriate purpose string keys in your Info.plist file. For example, you must include the NSCalendarsUsageDescription key to access the user’s Calendar data. If you don’t include the relevant purpose string keys, your app exits when it tries to access the data.

## 13.CallKit

The CallKit framework (CallKit.framework) lets VoIP apps integrate with the iPhone UI and give users a great experience. Use this framework to let users view and answer incoming VoIP calls on the lock screen and manage contacts from VoIP calls in the Phone app’s Favorites and Recents views.

CallKit also introduces app extensions that enable call blocking and caller identification. You can create an app extension that can associate a phone number with a name or tell the system when a number should be blocked.

## 14.News Publisher Enhancements

News Publisher makes it easy to deliver beautifully designed news, magazine, and web content to Apple News using the Apple News Format. Anyone can sign up, from major magazines or news organizations to independent publishers and bloggers. To get started or to learn more about recent updates, visit https://newsresources.apple.com.

## 15.Video Subscriber Account

iOS 10 introduces the Video Subscriber Account framework (VideoSubscriberAccount.framework) to help apps that support authenticated streaming or authenticated video on demand (also known as TV Everywhere) authenticate with their cable or satellite TV provider. Using the APIs in this framework can help you support a single sign-in experience in which users sign in once to unlock access in all of the streaming video apps that their subscription supports.

## 16.App Extensions

iOS 10 introduces several new extension points for which you can create an app extension, such as:

Call Directory

Intents

Intents UI

Messages

Notification Content

Notification Service

Sticker Pack

In addition, iOS 10 includes the following enhancements for third-party keyboard app extensions:

You can automatically detect the input language of a document by using the documentInputMode property of the UITextDocumentProxy class, and change your keyboard extension to align with that language (if supported). When you detect the input language in this way, you can do per-language keyboard switching such as what is built in to Messages.

The new handleInputModeListFromView:withEvent: method lets a keyboard extension display the system’s keyboard picker menu (that is, the globe key menu).

A keyboard extension should position the globe key in the same location as the system globe key for each orientation. Also, if you need to provide a custom key—to enable keyboard settings, for example—you should put this key in the same location as the dictation key in the system keyboard.

To learn more about creating app extensions in general, see App Extension Programming Guide.

## 17.Additional Framework Changes

In addition to the major changes described above, iOS 10 includes many other improvements.

### 17.1 AVFoundation Camera Capture

The media capture subsystem in AVFoundation framework (AVFoundation.framework) includes several important changes.
Dual Camera and Device Discovery

iPhone 7 Plus includes a dual camera, which combines separate wide-angle and telephoto cameras that serve together as a single capture device. When using the dual camera device, iOS automatically uses either or both cameras based on light levels, zoom factor, and other conditions to capture the highest quality image possible. When you use the AVCaptureDevice class for video or photo capture, you can choose to use the dual camera device to gain these features, or to specifically use only the wide-angle or telephoto camera for more manual control.

To access capture devices in iOS 10.0 and later, you can use either of the following methods:

Call the defaultDeviceWithDeviceType:mediaType:position: method. (Pass the AVCaptureDeviceTypeBuiltInDuoCamera device type to access the dual camera. That call returns nil for devices without a dual camera—in that case, you can call the same method again, passing the AVCaptureDeviceTypeBuiltInWideAngleCamera device type, to obtain the default back camera.)

Create an AVCaptureDeviceDiscoverySession object, passing the device attributes you want to use for capture, and enumerate its devices list to select a device for your capture session.

Note: The AVCaptureDevice methods devices and devicesWithMediaType: are deprecated in iOS 10, and do not provide access to the dual camera or telephoto camera.

When you use the dual camera capture device, RAW capture and most manual controls are not available. To use these features, specifically select either the wide-angle or telephoto capture device. For details on the capabilities of each capture device, see iOS Device Compatibility Reference.
New Photo Capture API

The new AVCapturePhotoOutput class provides a unified pipeline for all photography workflows, enabling more sophisticated control and monitoring of the entire capture process and including support for new features such as Live Photos and RAW format capture. You should transition to AVCapturePhotoOutput instead of AVCaptureStillImageOutput, which is deprecated in iOS 10.
Wide Color

The Camera Capture pipeline now enables capture in wide-gamut color formats on supported hardware. By default, an AVCaptureSession automatically configures for wide-color capture when appropriate for your capture workflow—for details, see iOS Device Compatibility Reference.

### 17.2 AVFoundation Media

The media playback and editing subsystem in AVFoundation framework (AVFoundation.framework) includes the following enhancements:

You no longer need to implement different behaviors for AVPlayerItem, depending on whether the content is a movie file or HLS content. In apps that link on or after iOS 10, you simply set the rate property and AVFoundation determines when enough content has been buffered to play without stalling.

The AVPlayerLooper class makes it easier to loop a particular piece of media content during playback.

Use the AVAssetDownloadURLSession class to download an asset, including an HLS stream, to the device and then play it later. When used in conjunction with FairPlay Streaming, you can download an encrypted HLS stream and play the stream securely at a later time.

### 17.3 AVKit

The AVKit framework (AVKit.framework) includes the updatesNowPlayingInfoCenter property, which indicates when the Now Playing Info Center should be updated.

### 17.4 Core Data

The Core Data framework (CoreData.framework) includes the following enhancements:

NSPersistentStoreCoordinator now maintains a connection pool for SQLite stores. Root NSManagedObjectContext objects (those without parent MOCs) transparently support concurrent fetching and faulting without serializing against each other.

NSManagedObjectContext objects with SQLite stores in WAL journal_mode support a new feature called query generations. These allow a MOC to be pinned to a version of the database at a point in time and perform all future fetching and faulting against that version of the database. Pinned MOCs are moved to the most recent transaction with any save, and query generations do not survive the process's life time.

The new NSPersistentContainer class provides your app with a high-level integration point that maintains references to your NSPersistentStoreCoordinator, NSManagedObjectModel, and other configuration resources.

Core Data now has tighter integration with Xcode and automatically generates and updates your NSManagedObject subclasses.

NSManagedObject includes several additional convenience methods, making it easier to fetch and create subclasses. NSManagedObject subclasses that have a 1:1 relationship with an entity now support entity.

Core Data introduces several API adjustments that provide better integration with Swift, including parameterized NSFetchRequest objects.

For more information, see Core Data Framework Reference.

### 17.5 Core Image

The Core Image framework (CoreImage.framework) includes several enhancements.

RAW image file support is now available on iOS devices that use the A8 or A9 CPU. Core Image can decode RAW images produced by several third-party cameras as well as images produced by the iSight camera of supported iOS devices (to learn more, see AVFoundation). To process RAW images, use filterWithImageData:options: or filterWithImageURL:options: to create a CIFilter object, adjust RAW processing options with the keys listed in RAW Image Options, and read the processed image from the filter’s outputImage property.

You can now insert custom processing into a Core Image filter graph by using the imageWithExtent:processorDescription:argumentDigest:inputFormat:outputFormat:options:roiCallback:processor: method. This method adds a callback block that Core Image invokes in between filters when processing an image for display or output; in the block, you can access the pixel buffers or Metal textures containing the current state of the processed image and apply your own image processing algorithms.

When using a custom processor block or writing filter kernels, you can process images in a color space other than the Core Image context’s working color space. Use the imageByColorMatchingWorkingSpaceToColorSpace: and imageByColorMatchingColorSpaceToWorkingSpace: methods to convert into and out of your color space before and after processing.

Performance is significantly improved for rendering UIImage objects that are backed by Core Image images (such as those created by using the initWithCIImage: initializer) in a UIImageView object. In addition, a Core Image–backed UIImage object that’s tagged with a wide-gamut color profile renders in a UIImageView object that uses wide-gamut color (on capable iOS devices).

Core Image kernel code can now request a specific output pixel format.

Core Image introduces five new filters:

CINinePartTiled

CINinePartStretched

CIHueSaturationValueGradient

CIEdgePreserveUpsampleFilter

CIClamp

### 17.6 Core Motion

The Core Motion framework (CoreMotion.framework) includes pedometer events, which enable apps to receive fast real-time notifications when users pause and resume while running. On supported devices, apps can use CMPedometer APIs to register to receive live pedometer events while running in the foreground or the background.

### 17.7 Foundation

The Foundation framework (Foundation.framework) contains many enhancements, such as:

The new NSDateInterval class defines a programmatic interface for calculating the duration of a time interval and determining whether a date falls within it, as well as comparing date intervals and checking to see whether they intersect.

The NSLocale class defines many new properties that you can use to get information about a locale and how it can be displayed.

The new NSMeasurement class helps you convert measurements into different units, and calculate the sum or difference between two measurements. The new NSMeasurementFormatter class helps you create localized representations of measurements when displaying quantities of units to the user.

The new NSUnit class and concrete NSDimension subclasses help you represent specific units of measure.

### 17.8 GameKit

The GameKit framework (GameKit.framework) includes the following changes and enhancements:

The Game Center app has been removed. If your game implements GameKit features, it must also implement the interface behavior necessary for the user to see these features. For example, if your game supports leaderboards, it could present a GKGameCenterViewController object or read the data directly from Game Center to implement a custom user interface.

A new account type, implemented by the GKCloudPlayer class, supports iCloud-only game accounts.

Game Center provides a new generalized solution for managing persistent storage of data on Game Center. A game session (GKGameSession) has a list of players who are the session’s participants. Your game’s implementation defines when and how a participant stores or retrieves data from the server or exchanges data between players. Game sessions can often replace existing turn-based matches, real-time matches, and persistent save games, and also enable other models of interaction between participants.

### 17.9 GameplayKit

The GameplayKit framework (GameplayKit.framework) includes the following changes and enhancements:

Procedural noise generation can be used to generate rich game worlds, create sophisticated natural-looking textures, and add realism to camera movement.

Spatial partitioning lets you partition your game world data so that the data in the game world can be searched efficiently.

A new Monte Carlo strategist (GKMonteCarloStrategist) helps you model games where exhaustive computation of possible moves is difficult.

The new decision tree API can enhance your game-building AI when you adopt decision-tree learning to generalize behavior based on data mining of logged player actions. To learn more, see GKDecisionTree and GKDecisionNode.

The GKAgent3D and GKGraphNode3D classes introduce 3D support to existing agent and path-finding behavior.

The new GKMeshGraph class provides a higher performance alternative to GKObstacleGraph, allowing you to produce more natural-looking output at the cost of less mathematically perfect paths.

The new GKScene and GKSKNodeComponent classes, combined with changes in SpriteKit and the Xcode editor, make integrating GameplayKit with SpriteKit easier than ever.

### 17.10 HealthKit

The HealthKit framework (HealthKit.framework) includes the following changes and enhancements:

The new HKCDADocument class, which represents a CDA document (that is, a document that follows the Clinical Document Architecture standard).

The new HKWorkoutConfiguration class, which lets you specify the activityType and locationType for a workout.

The new HKWheelchairUseObject characteristic object type and the related HKHealthStore method wheelchairUseWithError:.

New metadata keys that indicate weather types, such as HKWeatherConditionClear and HKWeatherConditionCloudy, and workout types, such as HKWorkoutActivityTypeFlexibility and HKWorkoutActivityTypeWheelchairRunPace.

### 17.11 HomeKit

In iOS 10, iPad can be configured to provide remote access to accessories, run automation triggers, and enable shared user permissions. In addition, the HomeKit framework (HomeKit.framework) adds support for camera and doorbell accessories and introduces many new APIs that help you:

View and interact with IP camera accessory profiles, display live streams and snapshots, and control a camera’s settings, speaker, and microphone

Access new services and characteristics

For the primary service, link services and valid values to provide more context and configuration about the accessories

You can also add and set up accessories using the Apple accessory setup workflow. To learn more, see HomeKit Framework Reference.

### 17.12 Metal

In iOS 10, Metal includes several new features and enhancements, such as:

Support for tessellation, enabling 3D apps and games to render more detailed scenes by efficiently describing complex geometry to the GPU.

Function Specialization, which makes it easy to create a collection of highly optimized functions to handle all the material and light combinations in a scene.

Resource Heaps and Memoryless Render Targets, which grant even finer-grained control of resource allocation to further optimize the performance of Metal-based apps.

To learn more, see What’s New in iOS 10, tvOS 10, and OS X 10.12 in Metal Programming Guide.

### 17.13 ModelIO

The ModelIO framework (ModelIO.framework) includes the following enhancements:

The USD file format is now supported.

The new MDLMaterialPropertyGraph class makes it easier to support runtime procedural changes to models.

The MDLVoxelArray class adds support for signed distance fields.

You can add assisted light probe placement by implementing the MDLLightProbeIrradianceDataSource protocol.

### 17.14 Photos

The Photos framework (Photos.framework) makes Live Photo editing available to apps that use Photos framework APIs to access the user's Photos library and to photo editing app extensions for use in the Photos and Camera apps. Specifically, the new PHLivePhotoEditingContext class lets you apply edits to the video and still photo content of a Live Photo, with an easy-to-use API based on Core Image enhancements. In addition, you can take advantage of the new Core Image processor feature to use other image processing technologies to perform edits. To learn more, see CIImageProcessorInput and CIImageProcessorOutput.

### 17.15 ReplayKit

The ReplayKit framework (ReplayKit.framework) includes the following enhancements:

ReplayKit supports broadcasting services so that a user can broadcast recorded media through a third-party site. You can implement support for this functionality by using the RPScreenRecorder, RPBroadcastActivityViewController, and RPBroadcastController classes.

To participate in ReplayKit broadcast, third-party broadcast services need to implement a pair of app extensions. The Broadcast UI extension provides a UI that lets users sign into the service and set up a broadcast. The Broadcast Upload extension receives movie clips and transmits them to the service.

### 17.16 SceneKit

The SceneKit framework (SceneKit.framework) includes several enhancements.

A new Physically Based Rendering (PBR) system allows you to leverage the latest in 3D graphics research to create more realistic results with simpler asset authoring. Specifically:

Use the new SCNLightingModelPhysicallyBased shading model to opt into PBR shading for materials. PBR materials require only three fundamental properties—diffuse, metalness, and roughness—to produce a wide range of realistic shading effects. (The normal, ambientOcclusion, and selfIllumination material properties also remain useful for PBR materials, but you can now ignore the large number of other properties used for traditional materials.)

PBR shading works best with environment-based lighting, which causes even diffuse surfaces to pick up the colors of the scene around them. Use the lightingEnvironment property to assign global image-based lighting to an entire scene, and place light probes in the Xcode scene editor to pick up the local lighting contributions from objects within your scene.

Authors of PBR scene content often prefer working in physically based terms, so you can now define lighting using intensity (in lumens) and color temperature (in degrees Kelvin), and import specifications for real-world light fixtures using the IESProfileURL property.

Add even more realism with the new HDR features and effects in the SCNCamera class. With HDR rendering, SceneKit captures a much wider range of brightness and contrast in a scene, then allows you to customize the tone mapping that adapts that scene for the narrower range of a device’s display. Enable exposure adaptation to create automatic effects when, for example, the player in your game moves from a darkened area into sunlight. Or use vignetting, color fringing, and color grading to add a filmic look to your game.

Although linear, more color-accurate rendering is the basis for PBR shading and HDR camera features, it produces better results even for traditional rendering. By default, SceneKit now performs all color calculations in a linear (not gamma-adjusted) color space, and uses the P3 color gamut of devices that include wide-color displays. This feature is enabled automatically for all apps linking against the iOS 10 SDK, and has a few ramifications for content design and asset management:

SceneKit color matches all colors. In previous versions, SceneKit would read only the color values from material colors specified as NSColor or UIColor objects, ignoring color profile information and assuming the sRGB color space.

SceneKit interprets color component values specified within shader modifier or custom Metal or OpenGL shader code in linear RGB space.

SceneKit reads and adjusts for color profile information in texture images. Design textures for a linear brightness ramp, and use Asset Catalogs in Xcode to make sure your images use the correct color profile.

If necessary, you can disable linear space rendering with the SCNDisableLinearSpaceRendering key in your app’s Info.plist file, and wide color rendering with the SCNDisableWideGamut key.

Geometry can now be loaded from scene files or programmatically defined using arbitrary polygon primitives (SCNGeometryPrimitiveTypePolygon). SceneKit automatically triangulates polygon meshes for rendering, but makes use of the underlying polygon mesh for more accurate surface subdivision (to learn more, see the subdivisionLevel property).

### 17.17 SpriteKit

The SpriteKit framework (SpriteKit.framework) includes the following enhancements:

A new tilemap solution supports square, hexagonal, and isometric tilemaps that make it easy to create 2D, 2.5D, and side-scroller games. The Xcode editor provides comprehensive support for organizing your tiles and creating your tilemap. For more information, see the SKTileMapNode, SKTileGroup, SKTileGroupRule, and SKTileSet classes .

The new SKWarpGeometry class is used to stretch or distort how a SKSpriteNode or SKEffectNode object is rendered. The warp is specified by a set of control points. New SKAction types can be used to animate between different warp effects.

A custom shader can use attributes that can be configured separately by each node that uses the shader. To add an attribute, create an SKAttribute object and attach it to your shader. Then, for each node that uses that shader, attach an SKAttributeValue object.]

The SKView class defines new methods that give you finer control over when and how your scene is rendered.

### 17.18 UIKit

The UIKit framework (UIKit.framework) includes many enhancements, such as:

New object-based, fully interactive and interruptible animation support that lets you retain control of your animations and link them with gesture-based interactions. To learn more, see UIViewAnimating Protocol Reference, UIViewPropertyAnimator Class Reference, UITimingCurveProvider Protocol Reference, UICubicTimingParameters Class Reference, and UISpringTimingParameters Class Reference.

The new UIPreviewInteraction class and UIPreviewInteractionDelegate protocol, which let you provide a custom user interface related to the peek and pop experience.

The new UIAccessibilityCustomRotor class and related classes that help you provide custom, context-specific functionality that assistive technologies such as VoiceOver can expose to users. For example, you might create a custom rotor that lets VoiceOver users find misspelled words in a document by repeatedly returning the range of text that contains the next misspelled word.

The UIAccessibilityIsAssistiveTouchRunning and UIAccessibilityAssistiveTouchStatusDidChangeNotification symbols, which let you determine when AssistiveTouch is enabled, and the UIAccessibilityHearingDevicePairedEar and UIAccessibilityHearingDevicePairedEarDidChangeNotification symbols, which give you the pairing status of MFi hearing aids.

New UIPasteboard API that automatically declares compatible content types for common class instances and new options that limit the lifetime of objects on the pasteboard.

New options in UIPasteboard

The new preferredFontForTextStyle:compatibleWithTraitCollection: UIFont method, which lets you add support for Dynamic Type in labels, text fields, and other text areas.

The UIContentSizeCategoryAdjusting protocol, which provides the adjustsFontForContentSizeCategory property that you can use to determine if the adopting element should update its font when the device’s UIContentSizeCategory changes.

Additional control over the appearance of the badge on a tab bar item, such as background color and text attributes.

Support for the refresh control in all scroll views and scroll-view subclasses, such as UICollectionView.

The new UIApplication method openURL:options:completionHandler:, which is executed asynchronously and calls the specified completion handler on the main queue (this method replaces openURL:).

The new UICloudSharingController class and UICloudSharingControllerDelegate protocol, which help you initiate a CloudKit sharing operation and display a view controller that lets users view and modify participants and start and stop sharing.

Enhancements to UICollectionView and the new UICollectionViewDataSourcePrefetching protocol, which help you take advantage of automatic prefetching of cells to improve the scrolling experience.

### 17.19 WebKit

The WebKit framework (WebKit.framework) introduces enhanced peek and pop support in WKWebView objects. In iOS 10, you can use the webView:shouldPreviewElement: method to determine if the specified web view should display the preview.

## 18.Deprecated APIs

iOS 10 deprecates several APIs, including:

The CloudKit CKDiscoverAllContactsOperation, CKDiscoveredUserInfo, CKDiscoverUserInfosOperation, CKFetchRecordChangesOperation classes. Instead, use CKDiscoverAllUserIdentitiesOperation, CKUserIdentity, CKDiscoverUserIdentitiesOperation, and CKFetchRecordZoneChangesOperation classes, all of which support record sharing.

Several CKSubscription APIs, such as methods and properties related to zone-based subscriptions (use CKRecordZoneSubscription APIs instead) and to query-based subscriptions (use CKQuerySubscription APIs instead).

Several NSPersistentStoreCoordinator symbols related to ubiquitous content.

The ADBannerView and ADInterstitialAd classes and related symbols in UIViewController.

Several SKUniform symbols related to floating point values. Instead, use methods such as initWithName:vectorFloat2: and uniformWithName:matrixFloat2x2:, as appropriate.

Several UIKit classes related to notifications, such as UILocalNotification, UIMutableUserNotificationAction, UIMutableUserNotificationCategory, UIUserNotificationAction, UIUserNotificationCategory, and UIUserNotificationSettings. Use APIs in the User Notifications framework instead (see User Notifications Framework Reference).

The handleActionWithIdentifier:forLocalNotification:, handleActionWithIdentifier:forRemoteNotification:, didReceiveLocalNotification:withCompletion:, and didReceiveRemoteNotification:withCompletion: WatchKit methods. Use handleActionWithIdentifier:forNotification: and didReceiveNotification:withCompletion: instead.

Also the notification-handling methods in WKExtensionDelegate, such as didReceiveRemoteNotification: and handleActionWithIdentifier:forRemoteNotification:. Instead of using these methods, first create a delegate object that adopts the UNUserNotificationCenterDelegate protocol and implement the appropriate methods. Then assign the delegate object to the delegate property of the singleton UNUserNotificationCenter object. 

For a complete list of specific API deprecations, see iOS 10.0 API Diffs.


